import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, c as claim_element, a as attr, b as insert, d as detach, f as create_slot, g as space, t as text, h as children, j as claim_space, k as claim_text, l as append, m as set_data, u as update_slot, n as transition_in, o as transition_out, p as onMount, q as binding_callbacks, r as action_destroyer, v as is_function, w as null_to_empty, x as toggle_class, y as listen, z as stop_propagation, A as prevent_default, B as compute_rest_props, C as assign, D as exclude_internal_props, E as bubble, F as create_component, G as claim_component, H as mount_component, I as get_spread_update, J as get_spread_object, K as destroy_component, L as run_all, M as createEventDispatcher, N as globals, O as group_outros, P as check_outros, Q as add_render_callback, R as create_bidirectional_transition, T as destroy_each, U as empty, V as noop, W as component_subscribe, _, X as set_style, Y as set_attributes, Z as query_selector_all, $ as locale, a0 as HtmlTag } from './client.3346ae17.js';

/* site/src/components/Card/Card.svelte generated by Svelte v3.31.0 */

function create_if_block(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
			this.h();
		},
		h() {
			if (img.src !== (img_src_value = /*image*/ ctx[1])) attr(img, "src", img_src_value);
			attr(img, "alt", "");
			attr(img, "class", "svelte-hnttiv");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*image*/ 2 && img.src !== (img_src_value = /*image*/ ctx[1])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

function create_fragment(ctx) {
	let article;
	let t0;
	let div;
	let h4;
	let t1;
	let t2;
	let p;
	let current;
	let if_block = /*image*/ ctx[1] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			article = element("article");
			if (if_block) if_block.c();
			t0 = space();
			div = element("div");
			h4 = element("h4");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			p = element("p");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			if (if_block) if_block.l(article_nodes);
			t0 = claim_space(article_nodes);
			div = claim_element(article_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h4 = claim_element(div_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t1 = claim_text(h4_nodes, /*title*/ ctx[0]);
			h4_nodes.forEach(detach);
			t2 = claim_space(div_nodes);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			if (default_slot) default_slot.l(p_nodes);
			p_nodes.forEach(detach);
			div_nodes.forEach(detach);
			article_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h4, "class", "svelte-hnttiv");
			attr(p, "class", "svelte-hnttiv");
			attr(div, "class", "svelte-hnttiv");
			attr(article, "class", "svelte-hnttiv");
		},
		m(target, anchor) {
			insert(target, article, anchor);
			if (if_block) if_block.m(article, null);
			append(article, t0);
			append(article, div);
			append(div, h4);
			append(h4, t1);
			append(div, t2);
			append(div, p);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*image*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(article, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*title*/ 1) set_data(t1, /*title*/ ctx[0]);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(article);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title } = $$props;
	let { image = null } = $$props;

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("image" in $$props) $$invalidate(1, image = $$props.image);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [title, image, $$scope, slots];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { title: 0, image: 1 });
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

/* node_modules/svelte-portal/src/Portal.svelte generated by Svelte v3.31.0 */

function create_fragment$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[4](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[4](null);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { target = document.body } = $$props;
	let targetEl;
	let portal;
	let componentInstance;

	onMount(() => {
		if (typeof target === "string") {
			targetEl = document.querySelector(target);

			// Force exit
			if (targetEl === null) {
				return () => {
					
				};
			}
		} else if (target instanceof HTMLElement) {
			targetEl = target;
		} else {
			throw new TypeError(`Unknown target type: ${typeof target}. Allowed types: String (CSS selector), HTMLElement.`);
		}

		portal = document.createElement("div");
		targetEl.appendChild(portal);
		portal.appendChild(componentInstance);

		return () => {
			targetEl.removeChild(portal);
		};
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			componentInstance = $$value;
			$$invalidate(0, componentInstance);
		});
	}

	$$self.$$set = $$props => {
		if ("target" in $$props) $$invalidate(1, target = $$props.target);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [componentInstance, target, $$scope, slots, div_binding];
}

class Portal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { target: 1 });
	}
}

function classOnChange(node, parameters) {
  let previousValue = null;
  let timeout;

  const update = ({ value, className, duration = 500 }) => {
    if (value !== previousValue) {
      previousValue = value;
      node.classList.add(className);
      timeout = setTimeout(
        () => node.classList.remove(className),
        duration + 10
      );
    }
  };

  update(parameters);

  return {
    update,
    destroy: () => clearTimeout(timeout)
  }
}

/* renderer/components/Button/Button.svelte generated by Svelte v3.31.0 */

function create_if_block_2(ctx) {
	let i;
	let t;

	return {
		c() {
			i = element("i");
			t = text(/*icon*/ ctx[2]);
			this.h();
		},
		l(nodes) {
			i = claim_element(nodes, "I", { class: true });
			var i_nodes = children(i);
			t = claim_text(i_nodes, /*icon*/ ctx[2]);
			i_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(i, "class", "material-icons svelte-bb1epg");
		},
		m(target, anchor) {
			insert(target, i, anchor);
			append(i, t);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4) set_data(t, /*icon*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (176:2) {#if text}
function create_if_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*text*/ ctx[0]);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*text*/ ctx[0]);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (178:2) {#if badge !== null}
function create_if_block$1(ctx) {
	let div;
	let t_value = (/*badge*/ ctx[5] > 999 ? "999+" : /*badge*/ ctx[5]) + "";
	let t;
	let classOnChange_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "badge svelte-bb1epg");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);

			if (!mounted) {
				dispose = action_destroyer(classOnChange_action = classOnChange.call(null, div, {
					value: /*badge*/ ctx[5],
					className: "halo"
				}));

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*badge*/ 32 && t_value !== (t_value = (/*badge*/ ctx[5] > 999 ? "999+" : /*badge*/ ctx[5]) + "")) set_data(t, t_value);

			if (classOnChange_action && is_function(classOnChange_action.update) && dirty & /*badge*/ 32) classOnChange_action.update.call(null, {
				value: /*badge*/ ctx[5],
				className: "halo"
			});
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$2(ctx) {
	let button;
	let t0;
	let t1;
	let t2;
	let button_data_testid_value;
	let button_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[2] && create_if_block_2(ctx);
	let if_block1 = /*text*/ ctx[0] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let if_block2 = /*badge*/ ctx[5] !== null && create_if_block$1(ctx);

	return {
		c() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { "data-testid": true, class: true });
			var button_nodes = children(button);
			if (if_block0) if_block0.l(button_nodes);
			t0 = claim_space(button_nodes);
			if (if_block1) if_block1.l(button_nodes);
			t1 = claim_space(button_nodes);
			if (default_slot) default_slot.l(button_nodes);
			t2 = claim_space(button_nodes);
			if (if_block2) if_block2.l(button_nodes);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(button, "data-testid", button_data_testid_value = /*$$restProps*/ ctx[7]["data-testid"]);
			attr(button, "class", button_class_value = "" + (null_to_empty(/*$$restProps*/ ctx[7].class) + " svelte-bb1epg"));
			toggle_class(button, "primary", /*primary*/ ctx[1]);
			toggle_class(button, "iconOnly", /*iconOnly*/ ctx[6]);
			toggle_class(button, "large", /*large*/ ctx[3]);
			toggle_class(button, "noBorder", /*noBorder*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append(button, t0);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(button, t2);
			if (if_block2) if_block2.m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[10])));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*icon*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*text*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (/*badge*/ ctx[5] !== null) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$1(ctx);
					if_block2.c();
					if_block2.m(button, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!current || dirty & /*$$restProps*/ 128 && button_data_testid_value !== (button_data_testid_value = /*$$restProps*/ ctx[7]["data-testid"])) {
				attr(button, "data-testid", button_data_testid_value);
			}

			if (!current || dirty & /*$$restProps*/ 128 && button_class_value !== (button_class_value = "" + (null_to_empty(/*$$restProps*/ ctx[7].class) + " svelte-bb1epg"))) {
				attr(button, "class", button_class_value);
			}

			if (dirty & /*$$restProps, primary*/ 130) {
				toggle_class(button, "primary", /*primary*/ ctx[1]);
			}

			if (dirty & /*$$restProps, iconOnly*/ 192) {
				toggle_class(button, "iconOnly", /*iconOnly*/ ctx[6]);
			}

			if (dirty & /*$$restProps, large*/ 136) {
				toggle_class(button, "large", /*large*/ ctx[3]);
			}

			if (dirty & /*$$restProps, noBorder*/ 144) {
				toggle_class(button, "noBorder", /*noBorder*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["text","primary","icon","large","noBorder","badge"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { text = null } = $$props;
	let { primary = false } = $$props;
	let { icon = null } = $$props;
	let { large = false } = $$props;
	let { noBorder = false } = $$props;
	let { badge = null } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("primary" in $$new_props) $$invalidate(1, primary = $$new_props.primary);
		if ("icon" in $$new_props) $$invalidate(2, icon = $$new_props.icon);
		if ("large" in $$new_props) $$invalidate(3, large = $$new_props.large);
		if ("noBorder" in $$new_props) $$invalidate(4, noBorder = $$new_props.noBorder);
		if ("badge" in $$new_props) $$invalidate(5, badge = $$new_props.badge);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	let iconOnly;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*text*/ 1) {
			 $$invalidate(6, iconOnly = !text);
		}
	};

	return [
		text,
		primary,
		icon,
		large,
		noBorder,
		badge,
		iconOnly,
		$$restProps,
		$$scope,
		slots,
		click_handler
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			text: 0,
			primary: 1,
			icon: 2,
			large: 3,
			noBorder: 4,
			badge: 5
		});
	}
}

/* renderer/components/Dropdown/Dropdown.svelte generated by Svelte v3.31.0 */

const { window: window_1 } = globals;

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	child_ctx[25] = list;
	child_ctx[26] = i;
	return child_ctx;
}

// (197:4) {#if withArrow}
function create_if_block_3(ctx) {
	let i;
	let t_value = `arrow_drop_${/*open*/ ctx[2] ? "up" : "down"}` + "";
	let t;

	return {
		c() {
			i = element("i");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			i = claim_element(nodes, "I", { class: true });
			var i_nodes = children(i);
			t = claim_text(i_nodes, t_value);
			i_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(i, "class", "material-icons arrow svelte-350du5");
			toggle_class(i, "iconOnly", /*iconOnly*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, i, anchor);
			append(i, t);
		},
		p(ctx, dirty) {
			if (dirty & /*open*/ 4 && t_value !== (t_value = `arrow_drop_${/*open*/ ctx[2] ? "up" : "down"}` + "")) set_data(t, t_value);

			if (dirty & /*iconOnly*/ 64) {
				toggle_class(i, "iconOnly", /*iconOnly*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (196:2) <Button {...$$restProps} {text} on:click={handleButtonClick}>
function create_default_slot_1(ctx) {
	let if_block_anchor;
	let if_block = /*withArrow*/ ctx[3] && create_if_block_3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*withArrow*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (205:2) {#if open}
function create_if_block$2(ctx) {
	let ul;
	let ul_transition;
	let current;
	let mounted;
	let dispose;
	let each_value = /*options*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			ul = claim_element(nodes, "UL", { role: true, class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(ul, "role", "menu");
			attr(ul, "class", "svelte-350du5");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[22](ul);
			current = true;

			if (!mounted) {
				dispose = [
					listen(ul, "introstart", /*handleMenuVisible*/ ctx[11]),
					listen(ul, "keydown", /*handleMenuKeyDown*/ ctx[12])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*options, undefined, select, dispatch, handleInteraction*/ 897) {
				each_value = /*options*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			add_render_callback(() => {
				if (!ul_transition) ul_transition = create_bidirectional_transition(ul, slide, {}, true);
				ul_transition.run(1);
			});

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			if (!ul_transition) ul_transition = create_bidirectional_transition(ul, slide, {}, false);
			ul_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
			/*ul_binding*/ ctx[22](null);
			if (detaching && ul_transition) ul_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (247:10) {:else}
function create_else_block(ctx) {
	let t0;
	let t1_value = (/*option*/ ctx[24].label || /*option*/ ctx[24]) + "";
	let t1;
	let if_block = /*option*/ ctx[24].icon && create_if_block_2$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(t1_value);
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			t0 = claim_space(nodes);
			t1 = claim_text(nodes, t1_value);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (/*option*/ ctx[24].icon) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*options*/ 1 && t1_value !== (t1_value = (/*option*/ ctx[24].label || /*option*/ ctx[24]) + "")) set_data(t1, t1_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (238:10) {#if option.Component}
function create_if_block_1$1(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*option*/ ctx[24].props];

	function close_handler() {
		return /*close_handler*/ ctx[17](/*option*/ ctx[24], /*each_value*/ ctx[25], /*option_index*/ ctx[26]);
	}

	var switch_value = /*option*/ ctx[24].Component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
		switch_instance.$on("close", close_handler);
		switch_instance.$on("close", /*handleInteraction*/ ctx[9]);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty & /*options*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*option*/ ctx[24].props)])
			: {};

			if (switch_value !== (switch_value = /*option*/ ctx[24].Component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					switch_instance.$on("close", close_handler);
					switch_instance.$on("close", /*handleInteraction*/ ctx[9]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (248:12) {#if option.icon}
function create_if_block_2$1(ctx) {
	let i;
	let t_value = /*option*/ ctx[24].icon + "";
	let t;

	return {
		c() {
			i = element("i");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			i = claim_element(nodes, "I", { class: true });
			var i_nodes = children(i);
			t = claim_text(i_nodes, t_value);
			i_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(i, "class", "material-icons svelte-350du5");
		},
		m(target, anchor) {
			insert(target, i, anchor);
			append(i, t);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 1 && t_value !== (t_value = /*option*/ ctx[24].icon + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (212:6) {#each options as option}
function create_each_block(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let t;
	let li_aria_disabled_value;
	let li_tabindex_value;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*option*/ ctx[24].Component) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function click_handler(...args) {
		return /*click_handler*/ ctx[18](/*option*/ ctx[24], /*each_value*/ ctx[25], /*option_index*/ ctx[26], ...args);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[19](/*option*/ ctx[24], /*each_value*/ ctx[25], /*option_index*/ ctx[26], ...args);
	}

	function focus_handler() {
		return /*focus_handler*/ ctx[20](/*option*/ ctx[24], /*each_value*/ ctx[25], /*option_index*/ ctx[26]);
	}

	function blur_handler() {
		return /*blur_handler*/ ctx[21](/*option*/ ctx[24], /*each_value*/ ctx[25], /*option_index*/ ctx[26]);
	}

	return {
		c() {
			li = element("li");
			if_block.c();
			t = space();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", {
				role: true,
				"aria-disabled": true,
				tabindex: true,
				class: true
			});

			var li_nodes = children(li);
			if_block.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(li, "role", "menuitem");
			attr(li, "aria-disabled", li_aria_disabled_value = /*option*/ ctx[24].disabled);
			attr(li, "tabindex", li_tabindex_value = /*option*/ ctx[24].disabled ? undefined : -1);
			attr(li, "class", "svelte-350du5");
			toggle_class(li, "disabled", /*option*/ ctx[24].disabled);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			append(li, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "click", click_handler),
					listen(li, "keydown", keydown_handler),
					listen(li, "focus", focus_handler),
					listen(li, "blur", blur_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(li, t);
			}

			if (!current || dirty & /*options*/ 1 && li_aria_disabled_value !== (li_aria_disabled_value = /*option*/ ctx[24].disabled)) {
				attr(li, "aria-disabled", li_aria_disabled_value);
			}

			if (!current || dirty & /*options*/ 1 && li_tabindex_value !== (li_tabindex_value = /*option*/ ctx[24].disabled ? undefined : -1)) {
				attr(li, "tabindex", li_tabindex_value);
			}

			if (dirty & /*options*/ 1) {
				toggle_class(li, "disabled", /*option*/ ctx[24].disabled);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (204:0) <Portal>
function create_default_slot(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*open*/ ctx[2] && create_if_block$2(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*open*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*open*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$3(ctx) {
	let span;
	let button_1;
	let t;
	let portal;
	let current;
	let mounted;
	let dispose;
	const button_1_spread_levels = [/*$$restProps*/ ctx[13], { text: /*text*/ ctx[1] }];

	let button_1_props = {
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < button_1_spread_levels.length; i += 1) {
		button_1_props = assign(button_1_props, button_1_spread_levels[i]);
	}

	button_1 = new Button({ props: button_1_props });
	button_1.$on("click", /*handleButtonClick*/ ctx[10]);

	portal = new Portal({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			span = element("span");
			create_component(button_1.$$.fragment);
			t = space();
			create_component(portal.$$.fragment);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {
				class: true,
				"aria-haspopup": true,
				"aria-expanded": true
			});

			var span_nodes = children(span);
			claim_component(button_1.$$.fragment, span_nodes);
			span_nodes.forEach(detach);
			t = claim_space(nodes);
			claim_component(portal.$$.fragment, nodes);
			this.h();
		},
		h() {
			attr(span, "class", "wrapper svelte-350du5");
			attr(span, "aria-haspopup", "menu");
			attr(span, "aria-expanded", /*open*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button_1, span, null);
			/*span_binding*/ ctx[16](span);
			insert(target, t, anchor);
			mount_component(portal, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window_1, "click", /*handleInteraction*/ ctx[9], true),
					listen(window_1, "scroll", /*handleInteraction*/ ctx[9], true)
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const button_1_changes = (dirty & /*$$restProps, text*/ 8194)
			? get_spread_update(button_1_spread_levels, [
					dirty & /*$$restProps*/ 8192 && get_spread_object(/*$$restProps*/ ctx[13]),
					dirty & /*text*/ 2 && { text: /*text*/ ctx[1] }
				])
			: {};

			if (dirty & /*$$scope, iconOnly, open, withArrow*/ 134217804) {
				button_1_changes.$$scope = { dirty, ctx };
			}

			button_1.$set(button_1_changes);

			if (!current || dirty & /*open*/ 4) {
				attr(span, "aria-expanded", /*open*/ ctx[2]);
			}

			const portal_changes = {};

			if (dirty & /*$$scope, menu, options, open*/ 134217749) {
				portal_changes.$$scope = { dirty, ctx };
			}

			portal.$set(portal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button_1.$$.fragment, local);
			transition_in(portal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button_1.$$.fragment, local);
			transition_out(portal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button_1);
			/*span_binding*/ ctx[16](null);
			if (detaching) detach(t);
			destroy_component(portal, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["value","options","valueAsText","withArrow","text","open"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { value } = $$props;
	let { options } = $$props;
	let { valueAsText = true } = $$props;
	let { withArrow = true } = $$props;
	let { text = null } = $$props;
	let { open = false } = $$props;
	const dispatch = createEventDispatcher();
	let menu;
	let button;

	function isInComponent(element) {
		return !element
		? false
		: element === menu || element.getAttribute("role") === "menu" || element === button
			? true
			: isInComponent(element.parentElement);
	}

	function select(option) {
		$$invalidate(14, value = option);
		handleButtonClick();
		dispatch("select", value);
	}

	function handleInteraction(evt) {
		if (evt.target && isInComponent(evt.target) || !open) {
			return;
		}

		handleButtonClick();
	}

	function handleButtonClick() {
		$$invalidate(2, open = !open);

		if (!open) {
			dispatch("close");
		}
	}

	async function handleMenuVisible() {
		const sav = menu.getAttribute("style");

		// reset styling to get final menu dimension
		menu.setAttribute("style", "");

		const buttonDim = button.getBoundingClientRect();
		const { width: menuWidth, height: menuHeight } = menu.getBoundingClientRect();
		const { innerWidth, innerHeight } = window;

		// restore styling to resume anumations
		menu.setAttribute("style", sav);

		const minWidth = buttonDim.width;
		let top = buttonDim.bottom;
		let left = buttonDim.left + (buttonDim.width - Math.max(menuWidth, buttonDim.width)) / 2;
		let right = null;
		let bottom = null;

		if (left + Math.max(menuWidth, minWidth) > innerWidth) {
			left = null;
			right = innerWidth - buttonDim.right;
		} else if (left < 0) {
			left = buttonDim.left;
		}

		if (buttonDim.top - menuHeight >= 0 && innerHeight < buttonDim.bottom + menuHeight) {
			top = null;
			bottom = innerHeight - buttonDim.top;
		}

		Object.assign(menu.style, {
			top: top !== null ? `${top}px` : "",
			left: left !== null ? `${left}px` : "",
			right: right !== null ? `${right}px` : "",
			bottom: bottom !== null ? `${bottom}px` : "",
			minWidth: `${minWidth}px`
		});

		if (menu.firstElementChild) {
			menu.firstElementChild.focus();
		}
	}

	function handleMenuKeyDown(evt) {
		const current = document.activeElement.closest("[role=\"menuitem\"]");

		if (!current) {
			return;
		}

		let focusable;

		switch (evt.key) {
			case "ArrowDown":
				focusable = current.nextElementSibling;
				while (focusable && focusable.hasAttribute("aria-disabled")) {
					focusable = focusable.nextElementSibling;
				}
				break;
			case "ArrowUp":
				focusable = current.previousElementSibling;
				while (focusable && focusable.hasAttribute("aria-disabled")) {
					focusable = focusable.previousElementSibling;
				}
				break;
			case "Home":
				focusable = menu.firstElementChild;
				break;
			case "End":
				focusable = menu.lastElementChild;
				break;
			case "Escape":
			case "Tab":
				handleButtonClick();
				break;
		}

		if (focusable) {
			focusable.focus();
			evt.preventDefault();
		}
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			button = $$value;
			$$invalidate(5, button);
		});
	}

	const close_handler = (option, each_value, option_index) => {
		$$invalidate(0, each_value[option_index].props.open = false, options);
		dispatch("select", option);
	};

	const click_handler = (option, each_value, option_index, evt) => {
		if (option.Component) {
			$$invalidate(0, each_value[option_index].props.open = true, options);
			evt.stopPropagation();
		} else {
			select(option);
		}
	};

	const keydown_handler = (option, each_value, option_index, evt) => {
		if (evt.key === "Enter" || evt.key === " " || evt.key === "ArrowRight") {
			if (option.Component) {
				$$invalidate(0, each_value[option_index].props.open = true, options);
				evt.stopPropagation();
			} else {
				select(option);
			}
		}
	};

	const focus_handler = (option, each_value, option_index) => option.props
	? $$invalidate(0, each_value[option_index].props.focus = true, options)
	: null;

	const blur_handler = (option, each_value, option_index) => option.props
	? $$invalidate(0, each_value[option_index].props.focus = false, options)
	: null;

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			menu = $$value;
			$$invalidate(4, menu);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("value" in $$new_props) $$invalidate(14, value = $$new_props.value);
		if ("options" in $$new_props) $$invalidate(0, options = $$new_props.options);
		if ("valueAsText" in $$new_props) $$invalidate(15, valueAsText = $$new_props.valueAsText);
		if ("withArrow" in $$new_props) $$invalidate(3, withArrow = $$new_props.withArrow);
		if ("text" in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ("open" in $$new_props) $$invalidate(2, open = $$new_props.open);
	};

	let iconOnly;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value, options*/ 16385) {
			 if (!value && options.length) {
				$$invalidate(14, value = options[0]);
			}
		}

		if ($$self.$$.dirty & /*valueAsText, value, text*/ 49154) {
			 if (valueAsText) {
				$$invalidate(1, text = value ? value.label || value : text);
			}
		}

		if ($$self.$$.dirty & /*valueAsText, text*/ 32770) {
			 $$invalidate(6, iconOnly = !valueAsText && !text);
		}
	};

	return [
		options,
		text,
		open,
		withArrow,
		menu,
		button,
		iconOnly,
		dispatch,
		select,
		handleInteraction,
		handleButtonClick,
		handleMenuVisible,
		handleMenuKeyDown,
		$$restProps,
		value,
		valueAsText,
		span_binding,
		close_handler,
		click_handler,
		keydown_handler,
		focus_handler,
		blur_handler,
		ul_binding
	];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			value: 14,
			options: 0,
			valueAsText: 15,
			withArrow: 3,
			text: 1,
			open: 2
		});
	}
}

/* site/src/components/DownloadButton/DownloadButtonItem.svelte generated by Svelte v3.31.0 */

function create_fragment$4(ctx) {
	let div;
	let img;
	let img_src_value;
	let span;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			img = element("img");
			span = element("span");
			t = text(/*label*/ ctx[0]);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*label*/ ctx[0]);
			span_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (img.src !== (img_src_value = "logos/" + /*os*/ ctx[1] + ".png")) attr(img, "src", img_src_value);
			attr(img, "alt", /*os*/ ctx[1]);
			attr(img, "class", "svelte-1smcbrw");
			attr(div, "class", "svelte-1smcbrw");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
			append(div, span);
			append(span, t);

			if (!mounted) {
				dispose = listen(div, "click", /*handleClick*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*os*/ 2 && img.src !== (img_src_value = "logos/" + /*os*/ ctx[1] + ".png")) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*os*/ 2) {
				attr(img, "alt", /*os*/ ctx[1]);
			}

			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { label } = $$props;
	let { os } = $$props;
	let { file } = $$props;
	let { baseUrl } = $$props;
	const dispatch = createEventDispatcher();

	function handleClick() {
		dispatch("close");
		window.open(`${baseUrl}/${file}`);
	}

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("os" in $$props) $$invalidate(1, os = $$props.os);
		if ("file" in $$props) $$invalidate(3, file = $$props.file);
		if ("baseUrl" in $$props) $$invalidate(4, baseUrl = $$props.baseUrl);
	};

	return [label, os, handleClick, file, baseUrl];
}

class DownloadButtonItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { label: 0, os: 1, file: 3, baseUrl: 4 });
	}
}

/* site/src/components/DownloadButton/DownloadButton.svelte generated by Svelte v3.31.0 */

function create_fragment$5(ctx) {
	let dropdown;
	let current;

	dropdown = new Dropdown({
			props: {
				class: "text-white",
				icon: "get_app",
				text: /*$_*/ ctx[0]("install _", { version }),
				primary: true,
				large: true,
				options: /*options*/ ctx[1],
				valueAsText: false
			}
		});

	return {
		c() {
			create_component(dropdown.$$.fragment);
		},
		l(nodes) {
			claim_component(dropdown.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(dropdown, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const dropdown_changes = {};
			if (dirty & /*$_*/ 1) dropdown_changes.text = /*$_*/ ctx[0]("install _", { version });
			dropdown.$set(dropdown_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dropdown, detaching);
		}
	};
}

const version = "1.0.0";

function instance$5($$self, $$props, $$invalidate) {
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(0, $_ = $$value));
	const baseUrl = `https://github.com/feugy/melodie/releases/download/v${version}`;

	const options = [
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.exe"),
				os: "windows",
				baseUrl,
				file: `melodie-setup-${version}.exe`
			}
		},
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.portable exe"),
				os: "windows",
				baseUrl,
				file: `melodie-${version}.exe`
			}
		},
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.portable zip"),
				os: "windows",
				baseUrl,
				file: `melodie-${version}-win.zip`
			}
		},
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.app image"),
				os: "linux",
				baseUrl,
				file: `melodie-${version}-x86_64.AppImage`
			}
		},
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.portable tar"),
				os: "linux",
				baseUrl,
				file: `melodie-${version}.tar.gz`
			}
		},
		{
			Component: DownloadButtonItem,
			props: {
				label: $_("download.dmg"),
				os: "macOS",
				baseUrl,
				file: `melodie-${version}.dmg`
			}
		}
	];

	return [$_, options];
}

class DownloadButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	}
}

/* site/src/components/Trapezium/Trapezium.svelte generated by Svelte v3.31.0 */

function create_fragment$6(ctx) {
	let section;
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			section = element("section");
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			section = claim_element(nodes, "SECTION", { style: true, class: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", {});
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			section_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_style(section, "--color", /*color*/ ctx[0]);
			set_style(section, "--clip-path", /*clipPath*/ ctx[1]);
			attr(section, "class", "svelte-i2y9a2");
		},
		m(target, anchor) {
			insert(target, section, anchor);
			append(section, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			if (!current || dirty & /*color*/ 1) {
				set_style(section, "--color", /*color*/ ctx[0]);
			}

			if (!current || dirty & /*clipPath*/ 2) {
				set_style(section, "--clip-path", /*clipPath*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(section);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

const offset = "7rem";

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { color = "#2e3141" } = $$props;
	let { inverted = false } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(0, color = $$props.color);
		if ("inverted" in $$props) $$invalidate(2, inverted = $$props.inverted);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	let clipPath;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*inverted*/ 4) {
			 $$invalidate(1, clipPath = inverted
			? `polygon(0% 0%, 100% ${offset}, 100% calc(100% - ${offset}), 0 100%)`
			: `polygon(0% ${offset}, 100% 0%, 100% 100%, 0 calc(100% - ${offset}))`);
		}
	};

	return [color, clipPath, inverted, $$scope, slots];
}

class Trapezium extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { color: 0, inverted: 2 });
	}
}

/* site/src/components/ReflectedImage/ReflectedImage.svelte generated by Svelte v3.31.0 */

function create_fragment$7(ctx) {
	let div;
	let img;
	let img_src_value;
	let img_levels = [/*$$restProps*/ ctx[2], { alt: "" }, { src: img_src_value = /*src*/ ctx[0] }];
	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = assign(img_data, img_levels[i]);
	}

	return {
		c() {
			div = element("div");
			img = element("img");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { style: true, class: true });
			var div_nodes = children(div);
			img = claim_element(div_nodes, "IMG", { alt: true, src: true });
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(img, img_data);
			toggle_class(img, "svelte-1azjigb", true);
			set_style(div, "--height", /*height*/ ctx[1]);
			set_style(div, "--src", "url('../" + /*src*/ ctx[0] + "')");
			attr(div, "class", "svelte-1azjigb");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
		},
		p(ctx, [dirty]) {
			set_attributes(img, img_data = get_spread_update(img_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				{ alt: "" },
				dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0]) && { src: img_src_value }
			]));

			toggle_class(img, "svelte-1azjigb", true);

			if (dirty & /*height*/ 2) {
				set_style(div, "--height", /*height*/ ctx[1]);
			}

			if (dirty & /*src*/ 1) {
				set_style(div, "--src", "url('../" + /*src*/ ctx[0] + "')");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["src","height"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { src } = $$props;
	let { height } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("height" in $$new_props) $$invalidate(1, height = $$new_props.height);
	};

	return [src, height, $$restProps];
}

class ReflectedImage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { src: 0, height: 1 });
	}
}

/* renderer/components/Sticky/Sticky.svelte generated by Svelte v3.31.0 */

function create_fragment$8(ctx) {
	let div;
	let span;
	let t;
	let nav_1;
	let nav_1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			div = element("div");
			span = element("span");
			t = space();
			nav_1 = element("nav");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			t = claim_space(div_nodes);
			nav_1 = claim_element(div_nodes, "NAV", { class: true, style: true });
			var nav_1_nodes = children(nav_1);
			if (default_slot) default_slot.l(nav_1_nodes);
			nav_1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "sentinel svelte-k06t7b");
			attr(nav_1, "class", nav_1_class_value = "" + (null_to_empty(/*$$restProps*/ ctx[4].class) + " svelte-k06t7b"));
			set_style(nav_1, "margin-bottom", "-" + /*height*/ ctx[2] + "px");
			toggle_class(nav_1, "floating", /*floating*/ ctx[3]);
			attr(div, "class", "wrapper svelte-k06t7b");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			/*span_binding*/ ctx[7](span);
			append(div, t);
			append(div, nav_1);

			if (default_slot) {
				default_slot.m(nav_1, null);
			}

			/*nav_1_binding*/ ctx[8](nav_1);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			if (!current || dirty & /*$$restProps*/ 16 && nav_1_class_value !== (nav_1_class_value = "" + (null_to_empty(/*$$restProps*/ ctx[4].class) + " svelte-k06t7b"))) {
				attr(nav_1, "class", nav_1_class_value);
			}

			if (!current || dirty & /*height*/ 4) {
				set_style(nav_1, "margin-bottom", "-" + /*height*/ ctx[2] + "px");
			}

			if (dirty & /*$$restProps, floating*/ 24) {
				toggle_class(nav_1, "floating", /*floating*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*span_binding*/ ctx[7](null);
			if (default_slot) default_slot.d(detaching);
			/*nav_1_binding*/ ctx[8](null);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let sentinel;
	let nav;
	let height;
	let floating = false;

	onMount(() => {
		const intersection = new IntersectionObserver(entries => {
				$$invalidate(3, floating = !entries[0].isIntersecting);
			});

		intersection.observe(sentinel);

		const resize = new ResizeObserver(entries => {
				$$invalidate(2, height = entries[0].contentRect.height);
			});

		resize.observe(nav);

		return () => {
			intersection.unobserve(sentinel);
			resize.unobserve(sentinel);
		};
	});

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			sentinel = $$value;
			$$invalidate(0, sentinel);
		});
	}

	function nav_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			nav = $$value;
			$$invalidate(1, nav);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	return [
		sentinel,
		nav,
		height,
		floating,
		$$restProps,
		$$scope,
		slots,
		span_binding,
		nav_1_binding
	];
}

class Sticky extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	}
}

/* site/src/routes/index.svelte generated by Svelte v3.31.0 */

const { document: document_1 } = globals;

function create_default_slot_8(ctx) {
	let nav;
	let img0;
	let img0_src_value;
	let img0_alt_value;
	let t0;
	let a0;
	let i0;
	let t1;
	let t2_value = /*$_*/ ctx[0]("intuitive") + "";
	let t2;
	let t3;
	let a1;
	let i1;
	let t4;
	let t5_value = /*$_*/ ctx[0]("organized") + "";
	let t5;
	let t6;
	let a2;
	let i2;
	let t7;
	let t8_value = /*$_*/ ctx[0]("reactive") + "";
	let t8;
	let t9;
	let a3;
	let i3;
	let t10;
	let t11_value = /*$_*/ ctx[0]("for geeks") + "";
	let t11;
	let t12;
	let span;
	let t13;
	let a4;
	let img1;
	let img1_src_value;
	let mounted;
	let dispose;

	return {
		c() {
			nav = element("nav");
			img0 = element("img");
			t0 = space();
			a0 = element("a");
			i0 = element("i");
			t1 = text("all_inclusive");
			t2 = text(t2_value);
			t3 = space();
			a1 = element("a");
			i1 = element("i");
			t4 = text("apps");
			t5 = text(t5_value);
			t6 = space();
			a2 = element("a");
			i2 = element("i");
			t7 = text("cached");
			t8 = text(t8_value);
			t9 = space();
			a3 = element("a");
			i3 = element("i");
			t10 = text("more_vert");
			t11 = text(t11_value);
			t12 = space();
			span = element("span");
			t13 = space();
			a4 = element("a");
			img1 = element("img");
			this.h();
		},
		l(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			img0 = claim_element(nav_nodes, "IMG", { src: true, alt: true, class: true });
			t0 = claim_space(nav_nodes);
			a0 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			i0 = claim_element(a0_nodes, "I", { class: true });
			var i0_nodes = children(i0);
			t1 = claim_text(i0_nodes, "all_inclusive");
			i0_nodes.forEach(detach);
			t2 = claim_text(a0_nodes, t2_value);
			a0_nodes.forEach(detach);
			t3 = claim_space(nav_nodes);
			a1 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			i1 = claim_element(a1_nodes, "I", { class: true });
			var i1_nodes = children(i1);
			t4 = claim_text(i1_nodes, "apps");
			i1_nodes.forEach(detach);
			t5 = claim_text(a1_nodes, t5_value);
			a1_nodes.forEach(detach);
			t6 = claim_space(nav_nodes);
			a2 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a2_nodes = children(a2);
			i2 = claim_element(a2_nodes, "I", { class: true });
			var i2_nodes = children(i2);
			t7 = claim_text(i2_nodes, "cached");
			i2_nodes.forEach(detach);
			t8 = claim_text(a2_nodes, t8_value);
			a2_nodes.forEach(detach);
			t9 = claim_space(nav_nodes);
			a3 = claim_element(nav_nodes, "A", { href: true, class: true });
			var a3_nodes = children(a3);
			i3 = claim_element(a3_nodes, "I", { class: true });
			var i3_nodes = children(i3);
			t10 = claim_text(i3_nodes, "more_vert");
			i3_nodes.forEach(detach);
			t11 = claim_text(a3_nodes, t11_value);
			a3_nodes.forEach(detach);
			t12 = claim_space(nav_nodes);
			span = claim_element(nav_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			t13 = claim_space(nav_nodes);
			a4 = claim_element(nav_nodes, "A", { target: true, href: true, class: true });
			var a4_nodes = children(a4);
			img1 = claim_element(a4_nodes, "IMG", { src: true, alt: true, class: true });
			a4_nodes.forEach(detach);
			nav_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (img0.src !== (img0_src_value = "favicon.png")) attr(img0, "src", img0_src_value);
			attr(img0, "alt", img0_alt_value = /*$_*/ ctx[0]("alt.home"));
			attr(img0, "class", "svelte-m7n09p");
			attr(i0, "class", "material-icons");
			attr(a0, "href", "#intuitive");
			attr(a0, "class", "svelte-m7n09p");
			attr(i1, "class", "material-icons");
			attr(a1, "href", "#organized");
			attr(a1, "class", "svelte-m7n09p");
			attr(i2, "class", "material-icons");
			attr(a2, "href", "#reactive");
			attr(a2, "class", "svelte-m7n09p");
			attr(i3, "class", "material-icons");
			attr(a3, "href", "#for-geeks");
			attr(a3, "class", "svelte-m7n09p");
			attr(span, "class", "flex-grow");
			if (img1.src !== (img1_src_value = "./logos/github.png")) attr(img1, "src", img1_src_value);
			attr(img1, "alt", "");
			attr(img1, "class", "svelte-m7n09p");
			attr(a4, "target", "_blank");
			attr(a4, "href", "https://github.com/feugy/melodie");
			attr(a4, "class", "svelte-m7n09p");
			attr(nav, "class", "svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, nav, anchor);
			append(nav, img0);
			append(nav, t0);
			append(nav, a0);
			append(a0, i0);
			append(i0, t1);
			append(a0, t2);
			append(nav, t3);
			append(nav, a1);
			append(a1, i1);
			append(i1, t4);
			append(a1, t5);
			append(nav, t6);
			append(nav, a2);
			append(a2, i2);
			append(i2, t7);
			append(a2, t8);
			append(nav, t9);
			append(nav, a3);
			append(a3, i3);
			append(i3, t10);
			append(a3, t11);
			append(nav, t12);
			append(nav, span);
			append(nav, t13);
			append(nav, a4);
			append(a4, img1);

			if (!mounted) {
				dispose = listen(img0, "click", /*click_handler*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && img0_alt_value !== (img0_alt_value = /*$_*/ ctx[0]("alt.home"))) {
				attr(img0, "alt", img0_alt_value);
			}

			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("intuitive") + "")) set_data(t2, t2_value);
			if (dirty & /*$_*/ 1 && t5_value !== (t5_value = /*$_*/ ctx[0]("organized") + "")) set_data(t5, t5_value);
			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("reactive") + "")) set_data(t8, t8_value);
			if (dirty & /*$_*/ 1 && t11_value !== (t11_value = /*$_*/ ctx[0]("for geeks") + "")) set_data(t11, t11_value);
		},
		d(detaching) {
			if (detaching) detach(nav);
			mounted = false;
			dispose();
		}
	};
}

// (141:2) <Trapezium color="transparent" inverted>
function create_default_slot_7(ctx) {
	let div1;
	let span;
	let h1;
	let t0_value = /*$_*/ ctx[0]("Mélodie is a music player") + "";
	let t0;
	let t1;
	let h2;
	let t2_value = /*$_*/ ctx[0]("intuitive portable and open source") + "";
	let t2;
	let t3;
	let downloadbutton;
	let t4;
	let div0;
	let reflectedimage;
	let current;
	downloadbutton = new DownloadButton({});

	reflectedimage = new ReflectedImage({
			props: {
				src: "images/screenshot-ui-" + /*$locale*/ ctx[1] + ".png",
				height: "350px"
			}
		});

	return {
		c() {
			div1 = element("div");
			span = element("span");
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			h2 = element("h2");
			t2 = text(t2_value);
			t3 = space();
			create_component(downloadbutton.$$.fragment);
			t4 = space();
			div0 = element("div");
			create_component(reflectedimage.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span = claim_element(div1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h1 = claim_element(span_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, t0_value);
			h1_nodes.forEach(detach);
			t1 = claim_space(span_nodes);
			h2 = claim_element(span_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, t2_value);
			h2_nodes.forEach(detach);
			t3 = claim_space(span_nodes);
			claim_component(downloadbutton.$$.fragment, span_nodes);
			span_nodes.forEach(detach);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(reflectedimage.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h1, "class", "svelte-m7n09p");
			attr(h2, "class", "svelte-m7n09p");
			attr(span, "class", "svelte-m7n09p");
			attr(div0, "class", "image-wrapper svelte-m7n09p");
			attr(div1, "class", "content svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, span);
			append(span, h1);
			append(h1, t0);
			append(span, t1);
			append(span, h2);
			append(h2, t2);
			append(span, t3);
			mount_component(downloadbutton, span, null);
			append(div1, t4);
			append(div1, div0);
			mount_component(reflectedimage, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Mélodie is a music player") + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]("intuitive portable and open source") + "")) set_data(t2, t2_value);
			const reflectedimage_changes = {};
			if (dirty & /*$locale*/ 2) reflectedimage_changes.src = "images/screenshot-ui-" + /*$locale*/ ctx[1] + ".png";
			reflectedimage.$set(reflectedimage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(downloadbutton.$$.fragment, local);
			transition_in(reflectedimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(downloadbutton.$$.fragment, local);
			transition_out(reflectedimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(downloadbutton);
			destroy_component(reflectedimage);
		}
	};
}

// (158:2) <Trapezium color="#4c5c96">
function create_default_slot_6(ctx) {
	let div1;
	let span;
	let h3;
	let t0_value = /*$_*/ ctx[0]("no frills just the basics") + "";
	let t0;
	let t1;
	let p;
	let raw_value = /*$_*/ ctx[0]("description.basics") + "";
	let t2;
	let div0;
	let reflectedimage;
	let current;

	reflectedimage = new ReflectedImage({
			props: {
				src: "images/screenshot-player-" + /*$locale*/ ctx[1] + ".png",
				height: "100px"
			}
		});

	return {
		c() {
			div1 = element("div");
			span = element("span");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = space();
			div0 = element("div");
			create_component(reflectedimage.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span = claim_element(div1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h3 = claim_element(span_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			h3_nodes.forEach(detach);
			t1 = claim_space(span_nodes);
			p = claim_element(span_nodes, "P", { class: true });
			var p_nodes = children(p);
			p_nodes.forEach(detach);
			span_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(reflectedimage.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "svelte-m7n09p");
			attr(p, "class", "svelte-m7n09p");
			attr(span, "class", "svelte-m7n09p");
			attr(div0, "class", "image-wrapper svelte-m7n09p");
			attr(div1, "class", "content svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, span);
			append(span, h3);
			append(h3, t0);
			append(span, t1);
			append(span, p);
			p.innerHTML = raw_value;
			append(div1, t2);
			append(div1, div0);
			mount_component(reflectedimage, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("no frills just the basics") + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*$_*/ 1) && raw_value !== (raw_value = /*$_*/ ctx[0]("description.basics") + "")) p.innerHTML = raw_value;			const reflectedimage_changes = {};
			if (dirty & /*$locale*/ 2) reflectedimage_changes.src = "images/screenshot-player-" + /*$locale*/ ctx[1] + ".png";
			reflectedimage.$set(reflectedimage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(reflectedimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(reflectedimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(reflectedimage);
		}
	};
}

// (176:2) <Trapezium color="#43527f" inverted>
function create_default_slot_5(ctx) {
	let div1;
	let span;
	let h3;
	let t0_value = /*$_*/ ctx[0]("organized so you do not have to") + "";
	let t0;
	let t1;
	let p;
	let raw_value = /*$_*/ ctx[0]("description.organized") + "";
	let t2;
	let div0;
	let reflectedimage;
	let current;

	reflectedimage = new ReflectedImage({
			props: {
				src: "images/screenshot-artists-" + /*$locale*/ ctx[1] + ".png",
				height: "275px"
			}
		});

	return {
		c() {
			div1 = element("div");
			span = element("span");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = space();
			div0 = element("div");
			create_component(reflectedimage.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span = claim_element(div1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h3 = claim_element(span_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			h3_nodes.forEach(detach);
			t1 = claim_space(span_nodes);
			p = claim_element(span_nodes, "P", { class: true });
			var p_nodes = children(p);
			p_nodes.forEach(detach);
			span_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(reflectedimage.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "svelte-m7n09p");
			attr(p, "class", "svelte-m7n09p");
			attr(span, "class", "svelte-m7n09p");
			attr(div0, "class", "image-wrapper svelte-m7n09p");
			attr(div1, "class", "content svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, span);
			append(span, h3);
			append(h3, t0);
			append(span, t1);
			append(span, p);
			p.innerHTML = raw_value;
			append(div1, t2);
			append(div1, div0);
			mount_component(reflectedimage, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("organized so you do not have to") + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*$_*/ 1) && raw_value !== (raw_value = /*$_*/ ctx[0]("description.organized") + "")) p.innerHTML = raw_value;			const reflectedimage_changes = {};
			if (dirty & /*$locale*/ 2) reflectedimage_changes.src = "images/screenshot-artists-" + /*$locale*/ ctx[1] + ".png";
			reflectedimage.$set(reflectedimage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(reflectedimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(reflectedimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(reflectedimage);
		}
	};
}

// (194:2) <Trapezium color="#353849">
function create_default_slot_4(ctx) {
	let div1;
	let span;
	let h3;
	let t0_value = /*$_*/ ctx[0]("it stays tuned") + "";
	let t0;
	let t1;
	let p;
	let raw_value = /*$_*/ ctx[0]("description.tuned") + "";
	let t2;
	let div0;
	let reflectedimage;
	let current;

	reflectedimage = new ReflectedImage({
			props: {
				src: "images/screenshot-artist-details-" + /*$locale*/ ctx[1] + ".png",
				height: "250px"
			}
		});

	return {
		c() {
			div1 = element("div");
			span = element("span");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = space();
			div0 = element("div");
			create_component(reflectedimage.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span = claim_element(div1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h3 = claim_element(span_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			h3_nodes.forEach(detach);
			t1 = claim_space(span_nodes);
			p = claim_element(span_nodes, "P", { class: true });
			var p_nodes = children(p);
			p_nodes.forEach(detach);
			span_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(reflectedimage.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "svelte-m7n09p");
			attr(p, "class", "svelte-m7n09p");
			attr(span, "class", "svelte-m7n09p");
			attr(div0, "class", "image-wrapper svelte-m7n09p");
			attr(div1, "class", "content svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, span);
			append(span, h3);
			append(h3, t0);
			append(span, t1);
			append(span, p);
			p.innerHTML = raw_value;
			append(div1, t2);
			append(div1, div0);
			mount_component(reflectedimage, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("it stays tuned") + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*$_*/ 1) && raw_value !== (raw_value = /*$_*/ ctx[0]("description.tuned") + "")) p.innerHTML = raw_value;			const reflectedimage_changes = {};
			if (dirty & /*$locale*/ 2) reflectedimage_changes.src = "images/screenshot-artist-details-" + /*$locale*/ ctx[1] + ".png";
			reflectedimage.$set(reflectedimage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(reflectedimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(reflectedimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(reflectedimage);
		}
	};
}

// (214:6) <Card image="logos/os.png" title={$_('works on your machine')}>
function create_default_slot_3(ctx) {
	let html_tag;
	let raw_value = /*$_*/ ctx[0]("description.portable") + "";
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && raw_value !== (raw_value = /*$_*/ ctx[0]("description.portable") + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (217:6) <Card image="logos/open-source.png" title={$_('open source')}>
function create_default_slot_2(ctx) {
	let html_tag;
	let raw_value = /*$_*/ ctx[0]("description.open source") + "";
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && raw_value !== (raw_value = /*$_*/ ctx[0]("description.open source") + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (220:6) <Card image="logos/js.png" title={$_('js powered')}>
function create_default_slot_1$1(ctx) {
	let html_tag;
	let raw_value = /*$_*/ ctx[0]("description.technologies") + "";
	let html_anchor;

	return {
		c() {
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 1 && raw_value !== (raw_value = /*$_*/ ctx[0]("description.technologies") + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (212:2) <Trapezium color="#2e3141" inverted>
function create_default_slot$1(ctx) {
	let div;
	let card0;
	let t0;
	let card1;
	let t1;
	let card2;
	let current;

	card0 = new Card({
			props: {
				image: "logos/os.png",
				title: /*$_*/ ctx[0]("works on your machine"),
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	card1 = new Card({
			props: {
				image: "logos/open-source.png",
				title: /*$_*/ ctx[0]("open source"),
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	card2 = new Card({
			props: {
				image: "logos/js.png",
				title: /*$_*/ ctx[0]("js powered"),
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(card0.$$.fragment);
			t0 = space();
			create_component(card1.$$.fragment);
			t1 = space();
			create_component(card2.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(card0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(card1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(card2.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "content flex-wrap svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(card0, div, null);
			append(div, t0);
			mount_component(card1, div, null);
			append(div, t1);
			mount_component(card2, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const card0_changes = {};
			if (dirty & /*$_*/ 1) card0_changes.title = /*$_*/ ctx[0]("works on your machine");

			if (dirty & /*$$scope, $_*/ 17) {
				card0_changes.$$scope = { dirty, ctx };
			}

			card0.$set(card0_changes);
			const card1_changes = {};
			if (dirty & /*$_*/ 1) card1_changes.title = /*$_*/ ctx[0]("open source");

			if (dirty & /*$$scope, $_*/ 17) {
				card1_changes.$$scope = { dirty, ctx };
			}

			card1.$set(card1_changes);
			const card2_changes = {};
			if (dirty & /*$_*/ 1) card2_changes.title = /*$_*/ ctx[0]("js powered");

			if (dirty & /*$$scope, $_*/ 17) {
				card2_changes.$$scope = { dirty, ctx };
			}

			card2.$set(card2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(card0.$$.fragment, local);
			transition_in(card1.$$.fragment, local);
			transition_in(card2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(card0.$$.fragment, local);
			transition_out(card1.$$.fragment, local);
			transition_out(card2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(card0);
			destroy_component(card1);
			destroy_component(card2);
		}
	};
}

function create_fragment$9(ctx) {
	let title_value;
	let t0;
	let sticky;
	let t1;
	let header;
	let trapezium0;
	let t2;
	let section0;
	let trapezium1;
	let t3;
	let section1;
	let trapezium2;
	let t4;
	let section2;
	let trapezium3;
	let t5;
	let section3;
	let trapezium4;
	let t6;
	let footer;
	let div;
	let span0;
	let t7_value = /*$_*/ ctx[0]("footer") + "";
	let t7;
	let t8;
	let span1;
	let a;
	let t9_value = /*$_*/ ctx[0]("photo by _", { name: "Larisa Birta" }) + "";
	let t9;
	let current;
	document_1.title = title_value = /*$_*/ ctx[0]("Mélodie");

	sticky = new Sticky({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	trapezium0 = new Trapezium({
			props: {
				color: "transparent",
				inverted: true,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	trapezium1 = new Trapezium({
			props: {
				color: "#4c5c96",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	trapezium2 = new Trapezium({
			props: {
				color: "#43527f",
				inverted: true,
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	trapezium3 = new Trapezium({
			props: {
				color: "#353849",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	trapezium4 = new Trapezium({
			props: {
				color: "#2e3141",
				inverted: true,
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			t0 = space();
			create_component(sticky.$$.fragment);
			t1 = space();
			header = element("header");
			create_component(trapezium0.$$.fragment);
			t2 = space();
			section0 = element("section");
			create_component(trapezium1.$$.fragment);
			t3 = space();
			section1 = element("section");
			create_component(trapezium2.$$.fragment);
			t4 = space();
			section2 = element("section");
			create_component(trapezium3.$$.fragment);
			t5 = space();
			section3 = element("section");
			create_component(trapezium4.$$.fragment);
			t6 = space();
			footer = element("footer");
			div = element("div");
			span0 = element("span");
			t7 = text(t7_value);
			t8 = space();
			span1 = element("span");
			a = element("a");
			t9 = text(t9_value);
			this.h();
		},
		l(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-yf2q4u\"]", document_1.head);
			head_nodes.forEach(detach);
			t0 = claim_space(nodes);
			claim_component(sticky.$$.fragment, nodes);
			t1 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			claim_component(trapezium0.$$.fragment, header_nodes);
			header_nodes.forEach(detach);
			t2 = claim_space(nodes);
			section0 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section0_nodes = children(section0);
			claim_component(trapezium1.$$.fragment, section0_nodes);
			section0_nodes.forEach(detach);
			t3 = claim_space(nodes);
			section1 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section1_nodes = children(section1);
			claim_component(trapezium2.$$.fragment, section1_nodes);
			section1_nodes.forEach(detach);
			t4 = claim_space(nodes);
			section2 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section2_nodes = children(section2);
			claim_component(trapezium3.$$.fragment, section2_nodes);
			section2_nodes.forEach(detach);
			t5 = claim_space(nodes);
			section3 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section3_nodes = children(section3);
			claim_component(trapezium4.$$.fragment, section3_nodes);
			section3_nodes.forEach(detach);
			t6 = claim_space(nodes);
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			div = claim_element(footer_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span0 = claim_element(div_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t7 = claim_text(span0_nodes, t7_value);
			span0_nodes.forEach(detach);
			t8 = claim_space(div_nodes);
			span1 = claim_element(div_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			a = claim_element(span1_nodes, "A", { class: true, target: true, href: true });
			var a_nodes = children(a);
			t9 = claim_text(a_nodes, t9_value);
			a_nodes.forEach(detach);
			span1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			footer_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(header, "class", "inverted-colors svelte-m7n09p");
			attr(section0, "id", "intuitive");
			attr(section0, "class", "svelte-m7n09p");
			attr(section1, "id", "organized");
			attr(section1, "class", "svelte-m7n09p");
			attr(section2, "id", "reactive");
			attr(section2, "class", "svelte-m7n09p");
			attr(section3, "id", "for-geeks");
			attr(section3, "class", "svelte-m7n09p");
			attr(span0, "class", "svelte-m7n09p");
			attr(a, "class", "underlined svelte-m7n09p");
			attr(a, "target", "_blank");
			attr(a, "href", "https://unsplash.com/photos/slbOcNlWNHA");
			attr(span1, "class", "svelte-m7n09p");
			attr(div, "class", "content svelte-m7n09p");
			attr(footer, "class", "inverted-colors svelte-m7n09p");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			mount_component(sticky, target, anchor);
			insert(target, t1, anchor);
			insert(target, header, anchor);
			mount_component(trapezium0, header, null);
			insert(target, t2, anchor);
			insert(target, section0, anchor);
			mount_component(trapezium1, section0, null);
			insert(target, t3, anchor);
			insert(target, section1, anchor);
			mount_component(trapezium2, section1, null);
			insert(target, t4, anchor);
			insert(target, section2, anchor);
			mount_component(trapezium3, section2, null);
			insert(target, t5, anchor);
			insert(target, section3, anchor);
			mount_component(trapezium4, section3, null);
			insert(target, t6, anchor);
			insert(target, footer, anchor);
			append(footer, div);
			append(div, span0);
			append(span0, t7);
			append(div, t8);
			append(div, span1);
			append(span1, a);
			append(a, t9);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*$_*/ 1) && title_value !== (title_value = /*$_*/ ctx[0]("Mélodie"))) {
				document_1.title = title_value;
			}

			const sticky_changes = {};

			if (dirty & /*$$scope, $_*/ 17) {
				sticky_changes.$$scope = { dirty, ctx };
			}

			sticky.$set(sticky_changes);
			const trapezium0_changes = {};

			if (dirty & /*$$scope, $locale, $_*/ 19) {
				trapezium0_changes.$$scope = { dirty, ctx };
			}

			trapezium0.$set(trapezium0_changes);
			const trapezium1_changes = {};

			if (dirty & /*$$scope, $locale, $_*/ 19) {
				trapezium1_changes.$$scope = { dirty, ctx };
			}

			trapezium1.$set(trapezium1_changes);
			const trapezium2_changes = {};

			if (dirty & /*$$scope, $locale, $_*/ 19) {
				trapezium2_changes.$$scope = { dirty, ctx };
			}

			trapezium2.$set(trapezium2_changes);
			const trapezium3_changes = {};

			if (dirty & /*$$scope, $locale, $_*/ 19) {
				trapezium3_changes.$$scope = { dirty, ctx };
			}

			trapezium3.$set(trapezium3_changes);
			const trapezium4_changes = {};

			if (dirty & /*$$scope, $_*/ 17) {
				trapezium4_changes.$$scope = { dirty, ctx };
			}

			trapezium4.$set(trapezium4_changes);
			if ((!current || dirty & /*$_*/ 1) && t7_value !== (t7_value = /*$_*/ ctx[0]("footer") + "")) set_data(t7, t7_value);
			if ((!current || dirty & /*$_*/ 1) && t9_value !== (t9_value = /*$_*/ ctx[0]("photo by _", { name: "Larisa Birta" }) + "")) set_data(t9, t9_value);
		},
		i(local) {
			if (current) return;
			transition_in(sticky.$$.fragment, local);
			transition_in(trapezium0.$$.fragment, local);
			transition_in(trapezium1.$$.fragment, local);
			transition_in(trapezium2.$$.fragment, local);
			transition_in(trapezium3.$$.fragment, local);
			transition_in(trapezium4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sticky.$$.fragment, local);
			transition_out(trapezium0.$$.fragment, local);
			transition_out(trapezium1.$$.fragment, local);
			transition_out(trapezium2.$$.fragment, local);
			transition_out(trapezium3.$$.fragment, local);
			transition_out(trapezium4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			destroy_component(sticky, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(header);
			destroy_component(trapezium0);
			if (detaching) detach(t2);
			if (detaching) detach(section0);
			destroy_component(trapezium1);
			if (detaching) detach(t3);
			if (detaching) detach(section1);
			destroy_component(trapezium2);
			if (detaching) detach(t4);
			if (detaching) detach(section2);
			destroy_component(trapezium3);
			if (detaching) detach(t5);
			if (detaching) detach(section3);
			destroy_component(trapezium4);
			if (detaching) detach(t6);
			if (detaching) detach(footer);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let $_;
	let $locale;
	component_subscribe($$self, _, $$value => $$invalidate(0, $_ = $$value));
	component_subscribe($$self, locale, $$value => $$invalidate(1, $locale = $$value));
	const segment = "";

	const click_handler = () => {
		window.location.hash = "";
		document.body.scrollTo(0, 0);
	};

	return [$_, $locale, segment, click_handler];
}

class Routes extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { segment: 2 });
	}

	get segment() {
		return this.$$.ctx[2];
	}
}

export default Routes;
